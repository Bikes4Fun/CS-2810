<html><head></head><body><h1>Sudoku solver</h1>

<p>In this project you will write a Sudoku solver in RISC-V assembly
language over the course of 10 steps. You are given a few pieces of
code to start:</p>

<ul>
<li><p>A function to read a Sudoku board from stdin (typically the
keyboard) into an internal board representation</p></li>

<li><p>A function to print a board to stdout (typically the screen)
complete with pencil markings</p></li>

<li><p>A <code>_start</code> function that will be updated with each step to test
the code you are writing</p></li>
</ul>

<p>This project is based around three principal features:</p>

<ol>
<li><p>A pencil mark calculator. In each unsolved square on the Sudoku
board, you will calculate which numbers are viable candidates to
solve the square. A viable candidate is any digit not already
present in a solved square in the same row, column, or box. A
standard technique for people solving Sudoku puzzles using
pencil and paper is to write the candidates out in each square
and then work to eliminate them until only one remains.</p></li>

<li><p>A naked sets calculator. This is an effective technique for
eliminating many candidates from pencil mark lists. As an
example, consider a row where two squares have pencil marks for
3 and 7 and nothing else. Without knowing which of the two must
be a 3 and which must be a 7, we can nevertheless infer that
both 3 and 7 are “used up” by those two squares and cannot
appear in any other squares in the row. This permits us to cross
off those two digits from all other pencil mark lists in the
row. Naked sets generalizes this to any set of squares within a
row, column, or box where the total number of unique candidates
in the combined pencil marks equals the number of squares in the
set.</p></li>

<li><p>A recursive guess-and-check solver. For many puzzles, naked set
calculations alone will be insufficient to solve the puzzle.
There are other interesting solving techniques we could apply
that emulate how humans might solve a puzzle, but we will jump
directly to a failsafe method: guess and check. You will find
the square with the fewest candidate pencil marks remaining and
try each value in turn. You will make a copy of the complete
board, write down one possible solution for the chosen square,
and then recursively call a solver to finish solving the puzzle.
If it succeeds, then the guess must have been correct, and if it
fails then the guess must have been incorrect so you will move
on to the next candidate for that single square. This technique
will always find the correct solution for any board, assuming
one exists.</p></li>
</ol>

<p>These instructions (and the instructions for other steps) will be
available in the <code>instructions</code> directory throughout this project.
You may find it helpful to refer back to the documentation for
earlier steps as you progress through the project.</p>

<h2>Pencil marks and the board representation</h2>

<p>We will represent a Sudoku board as an array of 81 integers, each 16
bits in size (so the whole board will be 162 bytes long). The board
will be stored in <em>row-major order</em>, meaning that the first row will
be the first nine elements of the array, the second row the nine
elements after that, etc.</p>

<p>Within each square, the bits of the value will represent the pencil
marks (the viable candidates) for that square using bits 1–9 of the
16-bit number (we will not use bit 0 or bits 10–15). For each bit at
position <em>n</em>, a one will mean that <em>n</em> is a viable candidate and a
zero will mean that <em>n</em> is not viable. A square with only one viable
candidate is a solved square.</p>

<p>Here is an example row from a puzzle with pencil marks filled in:</p>

<pre><code>+-----------------------+-----------------------+-----------------------+
|       | . . . | . 2 . | . 2 . |       | . 2 . |       | . 2 . |       |
|   1     4 . .   4 . . | . . .     3     4 . . |   5     . . .     6   |
|       | 7 . 9 | 7 . 9 | 7 8 . |       | . 8 9 |       | . 8 9 |       |
| - - - + - - - + - - - | - - - + - - - + - - - | - - - + - - - + - - - |
</code></pre>

<p>None of the pencil marks include 1, 3, 5, or 6, since these are all
direct conflicts with solved squares within the same row. Each set
of pencil marks is different because they also account for conflicts
from the column and box that each square occupies. The above row is
represented as these nine values:</p>

<ol>
<li>0b0000000000000010 = 0x0002</li>
<li>0b0000001010010000 = 0x0290</li>
<li>0b0000001010010100 = 0x0294</li>
<li>0b0000000110000100 = 0x0184</li>
<li>0b0000000000001000 = 0x0008</li>
<li>0b0000001100010100 = 0x0314</li>
<li>0b0000000000100000 = 0x0020</li>
<li>0b0000001100000100 = 0x0304</li>
<li>0b0000000001000000 = 0x0040</li>
</ol>

<p>This project will require extensive use of bit shifting and bitwise
operations to manipulate the squares. are treating a square as a set
of bits numbered 1–9 and using bitwise AND and OR operations to
implement set intersection and set union operations, respectively.
To review:</p>

<ul>
<li><p>To test if a value <em>n</em> is in a set, shift 1 left <em>n</em> times to
create a set containing only <em>n</em>. Then intersect (AND) it with
the set and check if the result is empty (zero). If it is, the
value <em>n</em> was not in the set.</p></li>

<li><p>To add a value <em>n</em> to a set, shift 1 left <em>n</em> times to create a
set containing only <em>n</em>, then union (OR) it with the set to add
it to the set.</p></li>
</ul>

<h2>The board lookup table</h2>

<p>You will frequently need to consider all elements in the same group,
i.e., within a single row, a single column, or a single box. To
simplify this process, you are given a lookup table with the
following format:</p>

<pre><code>00 01 02 03 04 05 06 07 08
09 10 11 12 13 14 15 16 17
18 19 20 21 22 23 24 25 26
... (6 more rows)
00 09 18 27 36 45 54 63 72
01 10 19 28 37 46 55 64 73
02 11 20 29 38 47 56 65 74
... (6 more columns)
00 01 02 09 10 11 18 19 20
03 04 05 12 13 14 21 22 23
06 07 08 15 16 17 24 25 26
... (6 more boxes)
</code></pre>

<p>It is a table with 27 rows, each containing 9 numbers. Rows int the
first group each contain the index values of a rows on a Sudoku
board. The first row:</p>

<pre><code>00 01 02 03 04 05 06 07 08
</code></pre>

<p>gives the index values in a complete board of the elements of the
first row. The second lookup table row</p>

<pre><code>09 10 11 12 13 14 15 16 17
</code></pre>

<p>gives the index values of the elements of the second row, etc.</p>

<p>The second group repeats this but each row gives the index values of
a single column in the board. The first such row</p>

<pre><code>00 09 18 27 36 45 54 63 72
</code></pre>

<p>gives the index values of the elements of the first column, while
the second row in this group</p>

<pre><code>01 10 19 28 37 46 55 64 73
</code></pre>

<p>lets you easily look up the elements of the second column, etc.</p>

<p>The third and final group of rows in the lookup table helps look up
the elements in a single 3×3 box. The first row</p>

<pre><code>00 01 02 09 10 11 18 19 20
</code></pre>

<p>gives the index values of the elements in the first 3×3 box, the
second row of this part of the lookup table</p>

<pre><code>03 04 05 12 13 14 21 22 23
</code></pre>

<p>gives the index values of the elements of the second box, etc.</p>

<p>This table lets you easily work with all of the 27 logical groupings
on a Sudoku board. Say you want to process each of the 27 groups:</p>

<pre><code>for group_start = 0; group_start &lt; 27*9; group_start += 9
    process_group(board, lookup_table+group_start)
</code></pre>

<p>In this example, <code>process_group</code> would be given the board and a
pointer to the beginning of a single row in the lookup table. Using
that row, it can easily find the nine elements of a row, column, or
box, but it does not need to know which group it is processing or
even the shape of that group. It can use the lookup table like this:</p>

<pre><code>process_group(int16_t *board, int8_t *group)
    for group_index = 0; group_index &lt; 9; group_index++
        board_index = group[group_index]
        element = board[board_index]
        ...
</code></pre>

<p>You will use this pattern in several parts of this project.</p>

<h2>Pencil marks: count the set bits</h2>

<p>Write a function in <code>pencil_marks.s</code> called <code>count_bits</code> with the
following function signature:</p>

<pre><code>count_bits(n) -&gt; # of bits set in n (only counting bits 0–9 inclusive)
</code></pre>

<p>It should count the number of set bits in positions 0 through 9
inclusive. For example, if it is called with the following value as
input:</p>

<pre><code>0b01011011011
</code></pre>

<p>it should return 7. If called with this:</p>

<pre><code>0b11011011011
</code></pre>

<p>it should still return 7, because it only counts the 10
least-significant bits.</p>

<p>You can test if a single bit is set by shifting <code>1</code> left <code>i</code> times
for each value of <code>i</code> from 0 to 9 inclusive and then ANDing
that value against the input and testing if the result is non-zero:</p>

<pre><code>count_bits(n) -&gt; # of bits
    count = 0
    index = 0
    while index &lt;= 9:
        mask = 1&lt;&lt;index
        temp = n &amp; mask
        if temp != 0:
            count += 1
        index += 1
    return count
</code></pre>
</body></html>