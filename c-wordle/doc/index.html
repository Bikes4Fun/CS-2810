<html><head></head><body><h2>Testing if a word is a viable guess</h2>

<p>Given a list of prior guesses and feedback on them, in this step you
will test if a word is a potential solution that incorporates all
feedback. For example, given this sequence of guesses and feedback:</p>

<pre><code>a(r)i(s)(e)
[r]o(u)t(e)
</code></pre>

<p>You would reject <code>super</code> (it has valid letters but does not have an
&#39;r&#39; in the first position) and you would accept <code>rules</code> (it has an
&#39;r&#39; as the first letter, a &#39;u&#39; that is not the third letter, an
&#39;e&#39; that is not the last letter, an &#39;s&#39; that is not the fourth
letter, and it does not contain &#39;a&#39;, &#39;i&#39;, &#39;o&#39;, or &#39;t&#39;).</p>

<p>In the file <code>is_viable.c</code> write a function <code>is_viable_candidate</code>
that matches the prototype in <code>wordle.h</code>.</p>

<p>You are given a candidate word to test and the list of guesses (with
a count so you know how many there are). I suggest the following
approach:</p>

<ul>
<li>Loop over the guesses and try to eliminate the candidate and if
you can find a reason to rule it out return false</li>
<li>If none of the information learned from prior guesses makes this
candidate invalid, then return true</li>
</ul>

<p>For each guess that you are considering, start by making a copy of
the candidate into a local variable (you can use <code>strcpy</code>):</p>

<pre><code class="language-c">char copy[6];
strcpy(copy, candidate);
</code></pre>

<p>This will allow you to cross letters off the word (see below)
without losing the original word.</p>

<p>Now perform a series of tests in order:</p>

<ol>
<li><p>Loop over the five letters of the guess and check for
<code>EXACT_HIT</code> letters. If you find one and the corresponding
position in the candidate is a mismatch, return false. If it is
a match, cross it off the candidate (put a non-letter character
like a &#39;_&#39; in that position).</p></li>

<li><p>Loop over the five letters of the guess again and check for
<code>PARTIAL_HIT</code> letters. When you find one, check if the candidate
has a matching letter in the same position. If so, return false.</p></li>

<li><p>Loop over the five letters again and check for <code>PARTIAL_HIT</code>
letters again. This time, when you find one scan all five
positions of the candidate to look for a match. If you find one,
cross it off (as before) and break out of the loop (you do not
want to inadvertently cross it off twice in two different
positions). If you do not find the letter anywhere, then return
false.</p></li>

<li><p>Loop over the five letters again, this time looking for <code>MISS</code>
letters. When you find one in the guess, scan all the positions
in the candidate and make sure there are no matches. If you find
a match, return false.</p></li>
</ol>

<p>This sequencing will correctly handle words with the same letter
appearing twice. Try following the procedure by hand on a few
examples to make sure you understand how it works.</p>
</body></html>